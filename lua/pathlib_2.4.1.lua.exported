local pathlib_2_4_1=[===============[--[==[ pathlib.lua (Cheat Engine Autorun)--]==]; --[==[ Windows pathlib-like helper for Cheat Engine Lua--]==]; local GLOBAL_NAME = "Path"; local Path = {}; Path.__index = Path; Path.version = "pathlib 2.4.1(CE)"; local eqcount = 15; --[==[ expose globally--]==]; _G[GLOBAL_NAME] = Path; --[==[--------------------------------------------------]==]; --[==[ helpers--]==]; --[==[--------------------------------------------------]==]; local function normalize(p); p = tostring(p); p = p:gsub("/", "\\"); p = p:gsub("\\+", "\\"); return p; end; local function trim_trailing_sep(p); return p:gsub("\\+$", ""); end; --[==[--------------------------------------------------]==]; --[==[ constructor--]==]; --[==[--------------------------------------------------]==]; function Path.new(p); assert(type(p) == "string", "Path must be a string"); return setmetatable({ path = normalize(p) }, Path); end; --[==[ allow Path("C:\\test")--]==]; setmetatable(Path, { __call = function(_, p) return Path.new(p) end }); --[==[--------------------------------------------------]==]; --[==[ metamethods--]==]; --[==[--------------------------------------------------]==]; function Path:__tostring(); return self.path; end; --[==[ allow Path("a") / "b"--]==]; function Path:__div(other); return self:join(other); end; --[==[ implement Path / "subfolder" syntax--]==]; Path.__div = function(self, other); --[==[ ensure self is a Path object--]==]; if type(self) == "string" then; self = Path(self); end; return self:join(other); end; --[==[--------------------------------------------------]==]; --[==[ core operations--]==]; --[==[--------------------------------------------------]==]; function Path:join(...); local p = trim_trailing_sep(self.path); for _, part in ipairs({...}) do; part = normalize(part):gsub("^\\+", ""); p = p .. "\\" .. part; end; return Path(p); end; function Path:resolve(); return Path(getFullPath(self.path)); end; --[==[--------------------------------------------------]==]; --[==[ filesystem queries--]==]; --[==[--------------------------------------------------]==]; function Path:exists(); local f = io.open(self.path, "r"); if f then; f:close(); return true; end; return false; end; function Path:is_file(); local f = io.open(self.path, "rb"); if f then; f:close(); return true; end; return false; end; function Path:is_dir(); local p = trim_trailing_sep(self.path); local pipe = io.popen('if exist "' .. p .. '\\*" (echo 1) else (echo 0)'); local res = pipe:read("*l"); pipe:close(); return res == "1"; end; --[==[--------------------------------------------------]==]; --[==[ read / write--]==]; --[==[--------------------------------------------------]==]; function Path:read_text(); local f = assert(io.open(self.path, "r"), "Cannot read file"); local data = f:read("*a"); f:close(); return data; end; function Path:write_text(text); local f = assert(io.open(self.path, "w"), "Cannot write file"); f:write(text); f:close(); end; --[==[ Static helper: write text to a destination path--]==]; function Path.write_file(text, dst); assert(type(text) == "string", "text must be a string"); --[==[ allow string or Path--]==]; if type(dst) == "string" then; dst = Path(dst); end; assert(getmetatable(dst) == Path, "dst must be a Path or string"); --[==[ ensure parent directory exists--]==]; local parent = dst:parent(); if parent and not parent:is_dir() then; parent:mkdir(true); end; local f = assert(io.open(dst.path, "w"), "Cannot write file: " .. dst.path); f:write(text); f:close(); return dst; end; --[==[--------------------------------------------------]==]; --[==[ directory operations--]==]; --[==[--------------------------------------------------]==]; function Path:mkdir(parents); if parents then; os.execute('mkdir "' .. self.path .. '" >nul 2>nul'); else os.execute('mkdir "' .. self.path .. '"'); end; return self; end; function Path:iterdir(); assert(self:is_dir(), "Not a directory"); local items = {}; local p = trim_trailing_sep(self.path); local cmd = io.popen('dir /b "' .. p .. '"'); for line in cmd:lines() do; items[#items + 1] = Path(p .. "\\" .. line); end; cmd:close(); return items; end; --[==[--------------------------------------------------]==]; --[==[ pathlib-like properties--]==]; --[==[--------------------------------------------------]==]; function Path:name(); return self.path:match("([^\\]+)$"); end; function Path:parent(); local p = self.path:match("^(.*)\\[^\\]+$"); return Path(p or self.path); end; function Path:suffix(); return self.path:match("(%.%w+)$"); end; function Path:stem(); local n = self:name(); return n and n:gsub("%.%w+$", ""); end; function Path:with_suffix(new_suffix); assert(new_suffix:sub(1, 1) == ".", "Suffix must start with '.'"); return self:parent() / (self:stem() .. new_suffix); end; function Path:parts(); local t = {}; for part in self.path:gmatch("[^\\]+") do; t[#t + 1] = part; end; return t; end; --[==[--------------------------------------------------]==]; --[==[ glob (basic)--]==]; --[==[--------------------------------------------------]==]; function Path:glob(pattern); assert(self:is_dir(), "Not a directory"); local results = {}; local p = trim_trailing_sep(self.path); local cmd = io.popen('dir /b "' .. p .. '\\' .. pattern .. '"'); for line in cmd:lines() do; results[#results + 1] = Path(p .. "\\" .. line); end; cmd:close(); return results; end; --[==[--------------------------------------------------]==]; --[==[ debug info--]==]; --[==[--------------------------------------------------]==]; function Path:info(); return { path = self.path, exists = self:exists(), is_file = self:is_file(), is_dir = self:is_dir(), name = self:name(), stem = self:stem(), suffix = self:suffix(); }; end; local function isNumArray(t); return type(t) == "table" and t[1] ~= nil; end; local function getItemsCount(t); if type(t) ~= "table" then return 0 end; --[==[ array-style--]==]; if isNumArray(t) then; return #t; else --[==[ map-style--]==]; local count = 0; for _ in pairs(t) do; count = count + 1; end; return count; end; end; local function convert_lua_to_flat_string_multiline(file_path); local function count_parens_outside_strings(line, paren_level, in_long_string); local i = 1; local len = #line; local in_string = in_long_string or nil  --[==[ track long string marker: e.g., "=+", nil if not inside--]==]; while i <= len do; local c = line:sub(i,i); if in_string then; --[==[ inside string--]==]; if type(in_string) == "string" then; --[==[ normal '...' or "..."--]==]; if c == in_string then; --[==[ check not escaped--]==]; local backslashes = 0; local j = i-1; while j > 0 and line:sub(j,j) == "\\" do; backslashes = backslashes + 1; j = j - 1; end; if backslashes % 2 == 0 then; in_string = nil --[==[ string closed--]==]; end; end; else --[==[ long string: in_string = number of '=' signs--]==]; local eq_count = 0; while line:sub(i,i) == "=" do; eq_count = eq_count + 1; i = i + 1; end; if line:sub(i,i) == "]" and eq_count == in_string then; in_string = nil; end; end; else --[==[ not in string--]==]; if c == "'" or c == '"' then; in_string = c; elseif c == "[" then --[==[ check for long string start--]==]; local j = i + 1; local eq_count = 0; while line:sub(j,j) == "=" do; eq_count = eq_count + 1; j = j + 1; end; if line:sub(j,j) == "[" then; --[==[ start long string--]==]; in_string = eq_count  --[==[ store number of '='--]==]; i = j  --[==[ skip past opening [--]==]; end; elseif c == "(" then paren_level = paren_level + 1; elseif c == ")" then paren_level = paren_level - 1; end; end; i = i + 1; end; return paren_level, in_string; end; local function split_comment_outside_strings(line); local paren = 0; local in_string = nil; local i = 1; while i <= #line do; local c = line:sub(i,i); local n = line:sub(i,i+1); if in_string then; if c == in_string then; in_string = nil; end; else if c == "'" or c == '"' then; in_string = c; elseif n == "--" then return line:sub(1, i-1), line:sub(i+2); end; end; i = i + 1; end; return line, nil; end; local f = assert(io.open(file_path, "r"), "Cannot open file: " .. file_path); local filename = file_path:match("^.+[\\/](.+)%.%w+$") or file_path:match("^(.+)%.%w+$") or file_path; local content = f:read("*a"); f:close(); content = content:gsub("\r\n", "\n"):gsub("\r", "\n"); local lines = {}; local paren_level = 0; local in_string = nil  --[==[ tracks if inside '..."', '...' or long string--]==]; for line in content:gmatch("[^\n]+") do; line = line:match("^%s*(.-)%s*$") --[==[ trim spaces--]==]; if line ~= "" then; --[==[ convert comments to block--]==]; local code, comment = split_comment_outside_strings(line); --[==[ drop lines that are only comments or whitespace--]==]; if code == "" and not comment then; goto continue; end; if comment then; comment = "--[==[" .. comment .. "--]==]"; line = code ~= "" and (code .. comment) or comment; else line = code; end; ::continue::; --[==[ update paren_level safely, handle multi-line strings--]==]; paren_level, in_string = count_parens_outside_strings(line, paren_level, in_string); --[==[ determine whether to skip semicolon--]==]; local skip_semicolon = false; --[==[ skip if inside multi-line parentheses or multi-line string--]==]; if paren_level > 0 or in_string then; skip_semicolon = true; end; --[==[ skip if line ends with {, (, [ or keywords--]==]; local last_char = line:match(".*(.)%s*$") or ""; if last_char == "{" or last_char == "(" or last_char == "[" then; skip_semicolon = true; end; if ( --[==[line:match("^end$") or--]==] line:match("^else$") or line:match("^elseif%s+") or line:match("^then$") or line:match("^do$") or line:match("^repeat$")) then; skip_semicolon = true; end; --[==[ add semicolon if safe--]==]; if not skip_semicolon and not line:match(";$") and not line:match(",$") then; line = line .. ";"; end; table.insert(lines, line); end; end; --[==[ join lines--]==]; local str1 = table.concat(lines, " "); local libname = filename:gsub("%.", "_"); local eq = string.rep("=", eqcount); local parts = { "local ", libname, "=[" .. eq .. "[", str1, "]" .. eq .. "]; load(", libname, ")();"; }; local str2 = table.concat(parts); return str2; end; function Path.exportLua(srcFilePath, dstFilePath); --[==[ normalize source--]==]; if type(srcFilePath) == "string" then; srcFilePath = Path(srcFilePath); end; assert(getmetatable(srcFilePath) == Path, "srcFilePath must be a Path or string"); --[==[ check source exists and is a file--]==]; assert(srcFilePath:exists(), "Source file does not exist: " .. tostring(srcFilePath)); assert(srcFilePath:is_file(), "Source is not a file: " .. tostring(srcFilePath)); --[==[ default destination: <src>.exported--]==]; if dstFilePath == nil then; dstFilePath = Path(tostring(srcFilePath) .. ".exported"); elseif type(dstFilePath) == "string" then dstFilePath = Path(dstFilePath); end; assert(getmetatable(dstFilePath) == Path, "dstFilePath must be a Path or string"); --[==[ ensure destination parent exists--]==]; local parent = dstFilePath:parent(); if parent and not parent:is_dir() then; parent:mkdir(true); end; --[==[ convert lua â†’ flattened multiline string--]==]; local texttosave = assert( convert_lua_to_flat_string_multiline(tostring(srcFilePath)), "Lua export conversion failed" ); --[==[ write output--]==]; Path.write_file(texttosave, dstFilePath); return dstFilePath; end; print("[Pathlib] Loaded " .. Path.version); return Path;]===============]; load(pathlib_2_4_1)();